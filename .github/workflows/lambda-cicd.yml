name: Lambda CI/CD Pipeline

'on':
  push:
    branches:
      - main
      - develop
  pull_request:
    branches:
      - main
  workflow_dispatch:
    inputs:
      environment:
        description: Environment to deploy to
        required: true
        default: staging
        type: choice
        options:
          - staging
          - production

env:
  NODE_VERSION: '18'
  AWS_REGION: us-east-1

permissions:
  id-token: write # Required for OIDC
  contents: read # Required to checkout code
  security-events: write # Required for Security Hub integration
  pull-requests: write # Required for PR comments

jobs:
  # Environment configuration and OIDC setup
  setup:
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.env-config.outputs.environment }}
      aws-region: ${{ steps.env-config.outputs.aws-region }}
    steps:
      - name: Determine Environment
        id: env-config
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            ENVIRONMENT="${{ github.event.inputs.environment }}"
          elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            ENVIRONMENT="production"
          else
            ENVIRONMENT="staging"
          fi

          echo "environment=${ENVIRONMENT}" >> $GITHUB_OUTPUT

          # Set AWS region
          echo "aws-region=us-east-1" >> $GITHUB_OUTPUT

  # Lint and test stage
  lint-and-test:
    runs-on: ubuntu-latest
    needs: setup
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: npm

      - name: Install dependencies
        run: npm ci

      - name: Run linting
        run: npm run lint

      - name: Run tests
        run: npm test -- --coverage

      - name: Upload test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-results
          path: |
            coverage/
            test-results.xml

  # Security scanning stage
  security-scan:
    runs-on: ubuntu-latest
    needs: setup
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_SECURITY_SCAN_ROLE_ARN }}
          role-session-name: GitHubActions-SecurityScan
          aws-region: ${{ needs.setup.outputs.aws-region }}
          audience: sts.amazonaws.com

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: npm

      - name: Install dependencies
        run: npm ci

      - name: Run SAST with CodeQL
        uses: github/codeql-action/init@v3
        with:
          languages: javascript

      - name: Perform CodeQL Analysis
        uses: github/codeql-action/analyze@v3

      - name: Run SCA with npm audit
        run: |
          npm audit --audit-level=high --json > npm-audit-results.json || true

      - name: Install Checkov
        run: |
          pip3 install checkov

      - name: Run Checkov IaC scanning
        run: |
          # Run Checkov and create SARIF output
          checkov -d . \
            --config-file docs/policies/ci-cd/.checkov.yaml \
            --output sarif \
            --output-file-path ./checkov-output \
            --quiet || true
          
          # Move the SARIF file to the expected location
          if [ -d "./checkov-output" ]; then
            find ./checkov-output -name "*.sarif" -exec mv {} ./checkov-results.sarif \;
          fi
          
          # Create empty SARIF file if none exists
          if [ ! -f "./checkov-results.sarif" ]; then
            echo '{"version":"2.1.0","runs":[{"tool":{"driver":{"name":"Checkov"}},"results":[]}]}' > ./checkov-results.sarif
          fi

      - name: Upload security scan results to Security Hub
        run: |
          # Convert and upload npm audit results to Security Hub
          python3 scripts/upload-security-findings.py \
            --source "npm-audit" \
            --file "npm-audit-results.json" \
            --environment "${{ needs.setup.outputs.environment }}"

          # Upload Checkov results to Security Hub
          python3 scripts/upload-security-findings.py \
            --source "checkov" \
            --file "checkov-results.sarif" \
            --environment "${{ needs.setup.outputs.environment }}"

      - name: Upload security artifacts
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: security-scan-results
          path: |
            npm-audit-results.json
            checkov-results.sarif

  # Build and package stage
  build-and-package:
    runs-on: ubuntu-latest
    needs:
      - setup
      - lint-and-test
      - security-scan
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ format('arn:aws:iam::{0}:role/{1}', secrets.AWS_ACCOUNT_ID_STAGING, secrets.AWS_ROLE_NAME_STAGING) }}
          role-session-name: GitHubActions-Build
          aws-region: ${{ needs.setup.outputs.aws-region }}
          audience: sts.amazonaws.com

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: npm

      - name: Install production dependencies
        run: npm ci --only=production

      - name: Build Lambda package
        run: |
          # Use optimized build script
          chmod +x scripts/build-lambda-package.sh
          ./scripts/build-lambda-package.sh

      - name: Validate package before signing
        run: |
          # Use validation script for pre-signing checks
          chmod +x scripts/validate-lambda-package.sh
          ./scripts/validate-lambda-package.sh -f lambda-function.zip -m basic

      - name: Sign Lambda package with AWS Signer (Optional)
        run: |
          # Check if signing profile exists before attempting to sign
          SIGNING_PROFILE="lambda-staging"
          S3_BUCKET="lambda-artifacts-staging"
          
          echo "Checking if signing profile '$SIGNING_PROFILE' exists..."
          
          # Check if signing profile exists
          if aws signer get-signing-profile --profile-name "$SIGNING_PROFILE" --region "${{ needs.setup.outputs.aws-region }}" >/dev/null 2>&1; then
            echo "Signing profile found. Proceeding with package signing..."
            
            chmod +x scripts/sign-lambda-package.sh
            ./scripts/sign-lambda-package.sh \
              --file lambda-function.zip \
              --environment "staging" \
              --profile "$SIGNING_PROFILE" \
              --bucket "$S3_BUCKET" \
              --region "${{ needs.setup.outputs.aws-region }}"
          else
            echo "Signing profile '$SIGNING_PROFILE' not found. Skipping code signing."
            echo "To enable code signing, create a signing profile in AWS Signer."
            
            # Create empty signing report for consistency
            cat > signing-report.json << EOF
          {
            "signingJobId": null,
            "signingProfile": "$SIGNING_PROFILE",
            "environment": "staging",
            "status": "skipped",
            "reason": "Signing profile not found",
            "timestamp": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")",
            "originalPackage": {
              "file": "lambda-function.zip"
            }
          }
          EOF
          fi

      - name: Validate signed package
        run: |
          # Validate the signed package
          SIGNED_PACKAGE=$(ls lambda-function-signed.zip 2>/dev/null || echo "lambda-function.zip")

          ./scripts/validate-lambda-package.sh -f "$SIGNED_PACKAGE" -m security

          # Additional integrity checks for signed package
          if [[ "$SIGNED_PACKAGE" == *"signed"* ]]; then
            echo "Signed package validation completed"

            # Verify signing report exists
            if [[ ! -f "signing-report.json" ]]; then
              echo "Warning: Signing report not found"
            else
              echo "Signing report generated successfully"
              cat signing-report.json
            fi
          fi

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: lambda-package-staging
          path: |
            lambda-function.zip
            package.json

  # Deploy Infrastructure to Staging
  deploy-infrastructure-staging:
    runs-on: ubuntu-latest
    needs:
      - setup
      - build-and-package
    if: always() && needs.build-and-package.result == 'success'
    environment:
      name: staging-infrastructure
      url: https://console.aws.amazon.com/cloudformation/home?region=${{ needs.setup.outputs.aws-region }}
    outputs:
      infrastructure-status: ${{ steps.infrastructure-result.outputs.status }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ format('arn:aws:iam::{0}:role/{1}', secrets.AWS_ACCOUNT_ID_STAGING, secrets.AWS_ROLE_NAME_STAGING) }}
          role-session-name: GitHubActions-Infrastructure-Staging
          aws-region: ${{ needs.setup.outputs.aws-region }}
          audience: sts.amazonaws.com

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "1.5.0"

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: lambda-package-staging

      - name: Prepare Lambda package for infrastructure
        run: |
          # Copy Lambda package to infrastructure directory
          cp lambda-function.zip infrastructure/lambda-function.zip
          
          # Verify package exists
          if [[ ! -f "infrastructure/lambda-function.zip" ]]; then
            echo "❌ Lambda package not found in infrastructure directory"
            exit 1
          fi
          
          echo "✅ Lambda package prepared for infrastructure deployment"

      - name: Deploy infrastructure with Terraform
        id: deploy-infrastructure
        working-directory: infrastructure
        run: |
          echo "🏗️ Deploying infrastructure for staging environment..."
          
          # Initialize Terraform
          terraform init
          
          # Select or create staging workspace
          terraform workspace select staging || terraform workspace new staging
          
          # Plan infrastructure deployment
          terraform plan \
            -var="environment=staging" \
            -var="lambda_function_name=lambda-function-staging" \
            -out=tfplan
          
          # Apply infrastructure changes
          terraform apply -auto-approve tfplan
          
          echo "✅ Infrastructure deployment completed"

      - name: Verify infrastructure deployment
        id: infrastructure-result
        working-directory: infrastructure
        run: |
          # Get infrastructure outputs
          terraform output -json > infrastructure-outputs.json
          
          echo "Infrastructure outputs:"
          cat infrastructure-outputs.json
          
          # Verify key resources exist
          LAMBDA_FUNCTION_ARN=$(terraform output -raw lambda_function_arn)
          PIPELINE_ARN=$(terraform output -raw pipeline_arn)
          S3_BUCKET=$(terraform output -raw s3_artifacts_bucket)
          
          if [[ -z "$LAMBDA_FUNCTION_ARN" || -z "$PIPELINE_ARN" || -z "$S3_BUCKET" ]]; then
            echo "❌ Infrastructure deployment verification failed - missing key resources"
            echo "status=failed" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          echo "✅ Infrastructure deployment verified successfully"
          echo "Lambda Function ARN: $LAMBDA_FUNCTION_ARN"
          echo "Pipeline ARN: $PIPELINE_ARN"
          echo "S3 Bucket: $S3_BUCKET"
          
          echo "status=success" >> $GITHUB_OUTPUT

      - name: Upload infrastructure artifacts
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: infrastructure-artifacts-staging
          path: |
            infrastructure/infrastructure-outputs.json
            infrastructure/terraform.tfstate
            infrastructure/tfplan

  # Deploy Lambda to Staging
  deploy-staging:
    runs-on: ubuntu-latest
    needs:
      - setup
      - build-and-package
      - deploy-infrastructure-staging
    if: always() && needs.deploy-infrastructure-staging.outputs.infrastructure-status == 'success'
    environment:
      name: staging
      url: https://console.aws.amazon.com/lambda/home?region=${{ needs.setup.outputs.aws-region }}
    outputs:
      deployment-status: ${{ steps.deployment-result.outputs.status }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ format('arn:aws:iam::{0}:role/{1}', secrets.AWS_ACCOUNT_ID_STAGING, secrets.AWS_ROLE_NAME_STAGING) }}
          role-session-name: GitHubActions-Deploy-Staging
          aws-region: ${{ needs.setup.outputs.aws-region }}
          audience: sts.amazonaws.com

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: lambda-package-staging

      - name: Download infrastructure artifacts
        uses: actions/download-artifact@v4
        with:
          name: infrastructure-artifacts-staging
          path: infrastructure-outputs

      - name: Deploy to Staging with CodeDeploy canary
        id: deploy-staging
        run: |
          echo "🚀 Deploying to Staging environment..."
          
          # Use canary deployment script
          chmod +x scripts/deploy-lambda-canary.sh

          # Determine package file (signed or unsigned)
          PACKAGE_FILE="lambda-function.zip"
          if [[ -f "lambda-function-signed.zip" ]]; then
            PACKAGE_FILE="lambda-function-signed.zip"
          fi

          # Deploy using canary script
          ./scripts/deploy-lambda-canary.sh \
            --function "lambda-function-staging" \
            --environment "staging" \
            --package "$PACKAGE_FILE" \
            --config "CodeDeployDefault.Lambda10PercentEvery5Minutes" \
            --timeout 600 \
            --region "${{ needs.setup.outputs.aws-region }}"

      - name: Verify staging deployment success
        id: deployment-result
        run: |
          # Check if deployment report exists and verify success
          if [[ -f "deployment-report.json" ]]; then
            echo "Deployment report generated:"
            cat deployment-report.json

            # Extract deployment status
            DEPLOYMENT_STATUS=$(jq -r '.deploymentStatus' deployment-report.json)

            if [[ "$DEPLOYMENT_STATUS" != "Succeeded" ]]; then
              echo "Deployment did not succeed: $DEPLOYMENT_STATUS"
              echo "status=failed" >> $GITHUB_OUTPUT
              exit 1
            fi

            echo "Deployment verified as successful"
            echo "status=success" >> $GITHUB_OUTPUT
          else
            echo "Warning: Deployment report not found"
            echo "status=failed" >> $GITHUB_OUTPUT
            exit 1
          fi

      - name: Post-deployment health check
        run: |
          echo "Running post-deployment health checks for staging..."
          
          # Wait for deployment to stabilize
          sleep 30
          
          # Test Lambda function invocation
          FUNCTION_NAME="lambda-function-staging"
          
          echo "Testing Lambda function: $FUNCTION_NAME"
          
          # Invoke function with test payload
          TEST_RESULT=$(aws lambda invoke \
            --function-name "$FUNCTION_NAME" \
            --payload '{"test": true, "source": "cicd-health-check", "environment": "staging"}' \
            --region "${{ needs.setup.outputs.aws-region }}" \
            response.json 2>&1 || echo "INVOKE_FAILED")
          
          if [[ "$TEST_RESULT" == *"INVOKE_FAILED"* ]]; then
            echo "❌ Lambda function invocation failed"
            echo "Error: $TEST_RESULT"
            exit 1
          fi
          
          # Check response
          if [[ -f "response.json" ]]; then
            echo "✅ Lambda function invocation successful"
            echo "Response:"
            cat response.json
            
            # Check for errors in response
            if grep -q "errorMessage\|errorType" response.json; then
              echo "❌ Lambda function returned an error"
              cat response.json
              exit 1
            fi
          else
            echo "❌ No response file generated"
            exit 1
          fi
          
          echo "✅ Staging deployment health check passed"

      - name: Upload staging deployment artifacts
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: deployment-artifacts-staging
          path: |
            deployment-report.json
            validation-report.json
            signing-report.json
            package-manifest.json
            response.json

  # Manual Approval for Production Deployment
  request-production-approval:
    runs-on: ubuntu-latest
    needs:
      - setup
      - deploy-staging
    if: needs.deploy-staging.outputs.deployment-status == 'success' && (github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch')
    environment:
      name: production-approval
    steps:
      - name: Request Production Deployment Approval
        run: |
          echo "🔔 Production deployment approval requested"
          echo "Staging deployment completed successfully"
          echo "Waiting for manual approval to proceed with production deployment..."
          echo ""
          echo "📋 Deployment Summary:"
          echo "  - Environment: Production"
          echo "  - Commit: ${{ github.sha }}"
          echo "  - Branch: ${{ github.ref }}"
          echo "  - Triggered by: ${{ github.actor }}"
          echo "  - Staging Status: ✅ Success"
          echo ""
          echo "⚠️  Please review the staging deployment before approving production deployment."

      - name: Send approval notification email
        run: |
          echo "📧 Sending approval notification email..."
          echo "Note: Email notification requires additional setup with services like SendGrid, AWS SES, or GitHub notifications"
          echo "For now, approvers will be notified via GitHub's built-in environment protection notifications"

  # Deploy Infrastructure to Production
  deploy-infrastructure-production:
    runs-on: ubuntu-latest
    needs:
      - setup
      - deploy-staging
      - request-production-approval
    if: needs.deploy-staging.outputs.deployment-status == 'success'
    environment:
      name: production-infrastructure
      url: https://console.aws.amazon.com/cloudformation/home?region=${{ needs.setup.outputs.aws-region }}
    outputs:
      infrastructure-status: ${{ steps.infrastructure-result.outputs.status }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ format('arn:aws:iam::{0}:role/{1}', secrets.AWS_ACCOUNT_ID_PROD, secrets.AWS_ROLE_NAME_PROD) }}
          role-session-name: GitHubActions-Infrastructure-Production
          aws-region: ${{ needs.setup.outputs.aws-region }}
          audience: sts.amazonaws.com

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "1.5.0"

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: lambda-package-staging

      - name: Prepare Lambda package for infrastructure
        run: |
          # Copy Lambda package to infrastructure directory
          cp lambda-function.zip infrastructure/lambda-function.zip
          
          # Verify package exists
          if [[ ! -f "infrastructure/lambda-function.zip" ]]; then
            echo "❌ Lambda package not found in infrastructure directory"
            exit 1
          fi
          
          echo "✅ Lambda package prepared for infrastructure deployment"

      - name: Deploy infrastructure with Terraform
        id: deploy-infrastructure
        working-directory: infrastructure
        run: |
          echo "🏗️ Deploying infrastructure for production environment..."
          
          # Initialize Terraform
          terraform init
          
          # Select or create production workspace
          terraform workspace select production || terraform workspace new production
          
          # Plan infrastructure deployment
          terraform plan \
            -var="environment=production" \
            -var="lambda_function_name=lambda-function-production" \
            -out=tfplan
          
          # Apply infrastructure changes
          terraform apply -auto-approve tfplan
          
          echo "✅ Infrastructure deployment completed"

      - name: Verify infrastructure deployment
        id: infrastructure-result
        working-directory: infrastructure
        run: |
          # Get infrastructure outputs
          terraform output -json > infrastructure-outputs.json
          
          echo "Infrastructure outputs:"
          cat infrastructure-outputs.json
          
          # Verify key resources exist
          LAMBDA_FUNCTION_ARN=$(terraform output -raw lambda_function_arn)
          PIPELINE_ARN=$(terraform output -raw pipeline_arn)
          S3_BUCKET=$(terraform output -raw s3_artifacts_bucket)
          
          if [[ -z "$LAMBDA_FUNCTION_ARN" || -z "$PIPELINE_ARN" || -z "$S3_BUCKET" ]]; then
            echo "❌ Infrastructure deployment verification failed - missing key resources"
            echo "status=failed" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          echo "✅ Infrastructure deployment verified successfully"
          echo "Lambda Function ARN: $LAMBDA_FUNCTION_ARN"
          echo "Pipeline ARN: $PIPELINE_ARN"
          echo "S3 Bucket: $S3_BUCKET"
          
          echo "status=success" >> $GITHUB_OUTPUT

      - name: Upload infrastructure artifacts
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: infrastructure-artifacts-production
          path: |
            infrastructure/infrastructure-outputs.json
            infrastructure/terraform.tfstate
            infrastructure/tfplan

  # Deploy Lambda to Production (after infrastructure)
  deploy-production:
    runs-on: ubuntu-latest
    needs:
      - setup
      - deploy-staging
      - request-production-approval
      - deploy-infrastructure-production
    if: needs.deploy-infrastructure-production.outputs.infrastructure-status == 'success'
    environment:
      name: production
      url: https://console.aws.amazon.com/lambda/home?region=${{ needs.setup.outputs.aws-region }}
    outputs:
      deployment-status: ${{ steps.deployment-result.outputs.status }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ format('arn:aws:iam::{0}:role/{1}', secrets.AWS_ACCOUNT_ID_PROD, secrets.AWS_ROLE_NAME_PROD) }}
          role-session-name: GitHubActions-Deploy-Production
          aws-region: ${{ needs.setup.outputs.aws-region }}
          audience: sts.amazonaws.com

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: lambda-package-staging

      - name: Download infrastructure artifacts
        uses: actions/download-artifact@v4
        with:
          name: infrastructure-artifacts-production
          path: infrastructure-outputs

      - name: Deploy to Production with CodeDeploy canary
        id: deploy-production
        run: |
          echo "🚀 Deploying to Production environment..."
          
          # Use canary deployment script
          chmod +x scripts/deploy-lambda-canary.sh

          # Determine package file (signed or unsigned)
          PACKAGE_FILE="lambda-function.zip"
          if [[ -f "lambda-function-signed.zip" ]]; then
            PACKAGE_FILE="lambda-function-signed.zip"
          fi

          # Deploy using canary script
          ./scripts/deploy-lambda-canary.sh \
            --function "lambda-function-production" \
            --environment "production" \
            --package "$PACKAGE_FILE" \
            --config "CodeDeployDefault.Lambda10PercentEvery5Minutes" \
            --timeout 600 \
            --region "${{ needs.setup.outputs.aws-region }}"

      - name: Verify production deployment success
        id: deployment-result
        run: |
          # Check if deployment report exists and verify success
          if [[ -f "deployment-report.json" ]]; then
            echo "Deployment report generated:"
            cat deployment-report.json

            # Extract deployment status
            DEPLOYMENT_STATUS=$(jq -r '.deploymentStatus' deployment-report.json)

            if [[ "$DEPLOYMENT_STATUS" != "Succeeded" ]]; then
              echo "Deployment did not succeed: $DEPLOYMENT_STATUS"
              echo "status=failed" >> $GITHUB_OUTPUT
              exit 1
            fi

            echo "Deployment verified as successful"
            echo "status=success" >> $GITHUB_OUTPUT
          else
            echo "Warning: Deployment report not found"
            echo "status=failed" >> $GITHUB_OUTPUT
            exit 1
          fi

      - name: Post-deployment health check
        run: |
          echo "Running post-deployment health checks for production..."
          
          # Wait for deployment to stabilize
          sleep 30
          
          # Test Lambda function invocation
          FUNCTION_NAME="lambda-function-production"
          
          echo "Testing Lambda function: $FUNCTION_NAME"
          
          # Invoke function with test payload
          TEST_RESULT=$(aws lambda invoke \
            --function-name "$FUNCTION_NAME" \
            --payload '{"test": true, "source": "cicd-health-check", "environment": "production"}' \
            --region "${{ needs.setup.outputs.aws-region }}" \
            response.json 2>&1 || echo "INVOKE_FAILED")
          
          if [[ "$TEST_RESULT" == *"INVOKE_FAILED"* ]]; then
            echo "❌ Lambda function invocation failed"
            echo "Error: $TEST_RESULT"
            exit 1
          fi
          
          # Check response
          if [[ -f "response.json" ]]; then
            echo "✅ Lambda function invocation successful"
            echo "Response:"
            cat response.json
            
            # Check for errors in response
            if grep -q "errorMessage\|errorType" response.json; then
              echo "❌ Lambda function returned an error"
              cat response.json
              exit 1
            fi
          else
            echo "❌ No response file generated"
            exit 1
          fi
          
          echo "✅ Production deployment health check passed"

      - name: Upload production deployment artifacts
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: deployment-artifacts-production
          path: |
            deployment-report.json
            validation-report.json
            signing-report.json
            package-manifest.json
            response.json

  # Rollback Staging (triggers on staging deployment failure)
  rollback-staging:
    runs-on: ubuntu-latest
    needs: 
      - setup
      - deploy-infrastructure-staging
      - deploy-staging
    if: always() && (needs.deploy-infrastructure-staging.result == 'failure' || needs.deploy-staging.result == 'failure')
    environment:
      name: staging-rollback
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ format('arn:aws:iam::{0}:role/{1}', secrets.AWS_ACCOUNT_ID_STAGING, secrets.AWS_ROLE_NAME_STAGING) }}
          role-session-name: GitHubActions-Rollback-Staging
          aws-region: ${{ needs.setup.outputs.aws-region }}
          audience: sts.amazonaws.com

      - name: Rollback staging to previous version
        run: |
          echo "🔄 Starting automatic rollback process for STAGING..."
          echo "Staging deployment failure detected - initiating emergency rollback"
          
          # Use rollback script for emergency rollback
          chmod +x scripts/rollback-lambda-deployment.sh

          ./scripts/rollback-lambda-deployment.sh \
            --function "lambda-function-staging" \
            --environment "staging" \
            --mode "emergency" \
            --region "${{ needs.setup.outputs.aws-region }}" \
            --force
          
          echo "🔄 Staging rollback process completed"

      - name: Verify staging rollback success
        run: |
          echo "🔍 Verifying staging rollback was successful..."
          
          # Test the rolled-back function
          FUNCTION_NAME="lambda-function-staging"
          
          # Wait for rollback to stabilize
          sleep 30
          
          # Test function invocation after rollback
          TEST_RESULT=$(aws lambda invoke \
            --function-name "$FUNCTION_NAME" \
            --payload '{"test": true, "source": "rollback-verification", "environment": "staging"}' \
            --region "${{ needs.setup.outputs.aws-region }}" \
            rollback-response.json 2>&1 || echo "ROLLBACK_TEST_FAILED")
          
          if [[ "$TEST_RESULT" == *"ROLLBACK_TEST_FAILED"* ]]; then
            echo "❌ Staging rollback verification failed - function still not working"
            echo "Error: $TEST_RESULT"
            exit 1
          fi
          
          if [[ -f "rollback-response.json" ]]; then
            echo "✅ Staging rollback verification successful"
            echo "Function response after rollback:"
            cat rollback-response.json
          fi
          
          echo "✅ Staging rollback completed and verified successfully"

      - name: Upload staging rollback artifacts
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: rollback-artifacts-staging
          path: |
            rollback-response.json
            rollback-report.json

  # Rollback Production (triggers on production deployment failure)
  rollback-production:
    runs-on: ubuntu-latest
    needs: 
      - setup
      - deploy-infrastructure-production
      - deploy-production
    if: always() && (needs.deploy-infrastructure-production.result == 'failure' || needs.deploy-production.result == 'failure')
    environment:
      name: production-rollback
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ format('arn:aws:iam::{0}:role/{1}', secrets.AWS_ACCOUNT_ID_PROD, secrets.AWS_ROLE_NAME_PROD) }}
          role-session-name: GitHubActions-Rollback-Production
          aws-region: ${{ needs.setup.outputs.aws-region }}
          audience: sts.amazonaws.com

      - name: Rollback production to previous version
        run: |
          echo "🔄 Starting automatic rollback process for PRODUCTION..."
          echo "Production deployment failure detected - initiating emergency rollback"
          
          # Use rollback script for emergency rollback
          chmod +x scripts/rollback-lambda-deployment.sh

          ./scripts/rollback-lambda-deployment.sh \
            --function "lambda-function-production" \
            --environment "production" \
            --mode "emergency" \
            --region "${{ needs.setup.outputs.aws-region }}" \
            --force
          
          echo "🔄 Production rollback process completed"

      - name: Verify production rollback success
        run: |
          echo "🔍 Verifying production rollback was successful..."
          
          # Test the rolled-back function
          FUNCTION_NAME="lambda-function-production"
          
          # Wait for rollback to stabilize
          sleep 30
          
          # Test function invocation after rollback
          TEST_RESULT=$(aws lambda invoke \
            --function-name "$FUNCTION_NAME" \
            --payload '{"test": true, "source": "rollback-verification", "environment": "production"}' \
            --region "${{ needs.setup.outputs.aws-region }}" \
            rollback-response.json 2>&1 || echo "ROLLBACK_TEST_FAILED")
          
          if [[ "$TEST_RESULT" == *"ROLLBACK_TEST_FAILED"* ]]; then
            echo "❌ Production rollback verification failed - function still not working"
            echo "Error: $TEST_RESULT"
            exit 1
          fi
          
          if [[ -f "rollback-response.json" ]]; then
            echo "✅ Production rollback verification successful"
            echo "Function response after rollback:"
            cat rollback-response.json
          fi
          
          echo "✅ Production rollback completed and verified successfully"

      - name: Notify production rollback completion
        if: always()
        run: |
          echo "📢 CRITICAL: Production rollback notification"
          echo "Environment: production"
          echo "Function: lambda-function-production"
          echo "Rollback Status: ${{ job.status }}"
          echo "Triggered by: Production deployment failure"
          echo "Commit: ${{ github.sha }}"
          echo "Branch: ${{ github.ref }}"
          
          # Create rollback report
          cat > rollback-report.json << EOF
          {
            "rollbackId": "${{ github.run_id }}-production-rollback",
            "environment": "production",
            "functionName": "lambda-function-production",
            "rollbackStatus": "${{ job.status }}",
            "triggeredBy": "production-deployment-failure",
            "originalCommit": "${{ github.sha }}",
            "branch": "${{ github.ref }}",
            "timestamp": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")",
            "deploymentFailureReason": "${{ needs.deploy-production.result }}"
          }
          EOF
          
          echo "Production rollback report generated:"
          cat rollback-report.json

      - name: Upload production rollback artifacts
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: rollback-artifacts-production
          path: |
            rollback-response.json
            rollback-report.json

  # Manual Rollback (can be triggered manually for any environment)
  manual-rollback:
    runs-on: ubuntu-latest
    needs: 
      - setup
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.environment != ''
    environment:
      name: ${{ github.event.inputs.environment }}-manual-rollback
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ github.event.inputs.environment == 'production' && format('arn:aws:iam::{0}:role/{1}', secrets.AWS_ACCOUNT_ID_PROD, secrets.AWS_ROLE_NAME_PROD) || format('arn:aws:iam::{0}:role/{1}', secrets.AWS_ACCOUNT_ID_STAGING, secrets.AWS_ROLE_NAME_STAGING) }}
          role-session-name: GitHubActions-Manual-Rollback
          aws-region: ${{ needs.setup.outputs.aws-region }}
          audience: sts.amazonaws.com

      - name: Manual rollback to previous version
        run: |
          echo "🔄 Starting MANUAL rollback process..."
          echo "Environment: ${{ github.event.inputs.environment }}"
          echo "Triggered by: ${{ github.actor }}"
          
          # Use rollback script for manual rollback
          chmod +x scripts/rollback-lambda-deployment.sh

          ./scripts/rollback-lambda-deployment.sh \
            --function "lambda-function-${{ github.event.inputs.environment }}" \
            --environment "${{ github.event.inputs.environment }}" \
            --mode "manual" \
            --region "${{ needs.setup.outputs.aws-region }}" \
            --force
          
          echo "🔄 Manual rollback process completed"

      - name: Verify manual rollback success
        run: |
          echo "🔍 Verifying manual rollback was successful..."
          
          # Test the rolled-back function
          FUNCTION_NAME="lambda-function-${{ github.event.inputs.environment }}"
          
          # Wait for rollback to stabilize
          sleep 30
          
          # Test function invocation after rollback
          TEST_RESULT=$(aws lambda invoke \
            --function-name "$FUNCTION_NAME" \
            --payload '{"test": true, "source": "manual-rollback-verification", "environment": "${{ github.event.inputs.environment }}"}' \
            --region "${{ needs.setup.outputs.aws-region }}" \
            rollback-response.json 2>&1 || echo "ROLLBACK_TEST_FAILED")
          
          if [[ "$TEST_RESULT" == *"ROLLBACK_TEST_FAILED"* ]]; then
            echo "❌ Manual rollback verification failed - function still not working"
            echo "Error: $TEST_RESULT"
            exit 1
          fi
          
          if [[ -f "rollback-response.json" ]]; then
            echo "✅ Manual rollback verification successful"
            echo "Function response after rollback:"
            cat rollback-response.json
          fi
          
          echo "✅ Manual rollback completed and verified successfully"

      - name: Upload manual rollback artifacts
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: rollback-artifacts-${{ github.event.inputs.environment }}-manual
          path: |
            rollback-response.json
            rollback-report.json