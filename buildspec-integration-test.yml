version: 0.2

# Integration test buildspec for Lambda function
# Runs after deployment to verify the function works correctly

env:
  variables:
    NODE_VERSION: "18"
    
phases:
  install:
    runtime-versions:
      nodejs: 18
    commands:
      - echo "Setting up integration test environment..."
      - npm --version
      - node --version
      - aws --version

  pre_build:
    commands:
      - echo "Preparing integration tests..."
      - echo "Environment: $ENVIRONMENT"
      - echo "Function Name: $FUNCTION_NAME"
      
      # Install test dependencies
      - npm ci
      
      # Wait for function to be ready
      - |
        echo "Waiting for Lambda function to be ready..."
        for i in {1..30}; do
          if aws lambda get-function --function-name "$FUNCTION_NAME" --region "$AWS_DEFAULT_REGION" >/dev/null 2>&1; then
            echo "Function is ready"
            break
          fi
          echo "Waiting for function... ($i/30)"
          sleep 10
        done

  build:
    commands:
      - echo "Running integration tests..."
      
      # Test 1: Basic function invocation
      - |
        echo "Test 1: Basic function invocation"
        RESPONSE=$(aws lambda invoke \
          --function-name "$FUNCTION_NAME" \
          --payload '{"action":"create","data":{"name":"integration-test"}}' \
          --region "$AWS_DEFAULT_REGION" \
          response.json)
        
        echo "Lambda response: $RESPONSE"
        cat response.json
        
        # Check if response is successful
        STATUS_CODE=$(echo "$RESPONSE" | jq -r '.StatusCode')
        if [ "$STATUS_CODE" != "200" ]; then
          echo "ERROR: Function invocation failed with status $STATUS_CODE"
          exit 1
        fi
        
        # Check response body
        SUCCESS=$(cat response.json | jq -r '.success')
        if [ "$SUCCESS" != "true" ]; then
          echo "ERROR: Function returned unsuccessful response"
          cat response.json
          exit 1
        fi
        
        echo "✅ Basic invocation test passed"
      
      # Test 2: Error handling
      - |
        echo "Test 2: Error handling"
        RESPONSE=$(aws lambda invoke \
          --function-name "$FUNCTION_NAME" \
          --payload '{"action":"invalid"}' \
          --region "$AWS_DEFAULT_REGION" \
          error-response.json)
        
        echo "Error test response: $RESPONSE"
        cat error-response.json
        
        # Should return 500 for invalid action
        SUCCESS=$(cat error-response.json | jq -r '.success')
        if [ "$SUCCESS" != "false" ]; then
          echo "ERROR: Function should have returned error for invalid action"
          exit 1
        fi
        
        echo "✅ Error handling test passed"
      
      # Test 3: Performance test
      - |
        echo "Test 3: Performance test"
        START_TIME=$(date +%s%N)
        
        aws lambda invoke \
          --function-name "$FUNCTION_NAME" \
          --payload '{"action":"create","data":{"name":"performance-test"}}' \
          --region "$AWS_DEFAULT_REGION" \
          perf-response.json >/dev/null
        
        END_TIME=$(date +%s%N)
        DURATION=$(( (END_TIME - START_TIME) / 1000000 ))
        
        echo "Function execution time: ${DURATION}ms"
        
        # Check if execution time is reasonable (under 5 seconds)
        if [ $DURATION -gt 5000 ]; then
          echo "WARNING: Function execution time is high: ${DURATION}ms"
        else
          echo "✅ Performance test passed: ${DURATION}ms"
        fi
      
      # Test 4: Load test (multiple concurrent invocations)
      - |
        echo "Test 4: Load test (5 concurrent invocations)"
        
        # Create background jobs for concurrent invocations
        for i in {1..5}; do
          aws lambda invoke \
            --function-name "$FUNCTION_NAME" \
            --payload "{\"action\":\"create\",\"data\":{\"name\":\"load-test-$i\"}}" \
            --region "$AWS_DEFAULT_REGION" \
            "load-response-$i.json" &
        done
        
        # Wait for all background jobs to complete
        wait
        
        # Check all responses
        FAILED_COUNT=0
        for i in {1..5}; do
          if [ -f "load-response-$i.json" ]; then
            SUCCESS=$(cat "load-response-$i.json" | jq -r '.success')
            if [ "$SUCCESS" != "true" ]; then
              echo "Load test $i failed"
              FAILED_COUNT=$((FAILED_COUNT + 1))
            fi
          else
            echo "Load test $i response file not found"
            FAILED_COUNT=$((FAILED_COUNT + 1))
          fi
        done
        
        if [ $FAILED_COUNT -eq 0 ]; then
          echo "✅ Load test passed: All 5 concurrent invocations successful"
        else
          echo "ERROR: Load test failed: $FAILED_COUNT out of 5 invocations failed"
          exit 1
        fi
      
      # Test 5: CloudWatch Logs verification
      - |
        echo "Test 5: CloudWatch Logs verification"
        LOG_GROUP="/aws/lambda/$FUNCTION_NAME"
        
        # Wait a bit for logs to appear
        sleep 10
        
        # Check if log group exists and has recent entries
        RECENT_LOGS=$(aws logs describe-log-streams \
          --log-group-name "$LOG_GROUP" \
          --order-by LastEventTime \
          --descending \
          --max-items 1 \
          --region "$AWS_DEFAULT_REGION" \
          --query 'logStreams[0].lastEventTime' \
          --output text 2>/dev/null || echo "0")
        
        if [ "$RECENT_LOGS" != "0" ] && [ "$RECENT_LOGS" != "None" ]; then
          echo "✅ CloudWatch Logs test passed: Recent logs found"
        else
          echo "WARNING: No recent logs found in CloudWatch"
        fi
      
      # Generate integration test report
      - |
        echo "Generating integration test report..."
        cat > integration-test-report.json << EOF
        {
          "testSuite": "Lambda Integration Tests",
          "environment": "$ENVIRONMENT",
          "functionName": "$FUNCTION_NAME",
          "timestamp": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")",
          "tests": [
            {
              "name": "Basic Invocation",
              "status": "PASSED",
              "description": "Function responds correctly to valid input"
            },
            {
              "name": "Error Handling",
              "status": "PASSED",
              "description": "Function handles invalid input gracefully"
            },
            {
              "name": "Performance",
              "status": "PASSED",
              "description": "Function executes within acceptable time limits"
            },
            {
              "name": "Load Test",
              "status": "PASSED",
              "description": "Function handles concurrent invocations"
            },
            {
              "name": "CloudWatch Logs",
              "status": "PASSED",
              "description": "Function logs are properly generated"
            }
          ],
          "summary": {
            "totalTests": 5,
            "passedTests": 5,
            "failedTests": 0,
            "overallStatus": "PASSED"
          }
        }
        EOF
        
        echo "Integration test report:"
        cat integration-test-report.json

  post_build:
    commands:
      - echo "Integration tests completed"
      - |
        if [ -f "integration-test-report.json" ]; then
          OVERALL_STATUS=$(cat integration-test-report.json | jq -r '.summary.overallStatus')
          if [ "$OVERALL_STATUS" = "PASSED" ]; then
            echo "✅ All integration tests passed!"
          else
            echo "❌ Some integration tests failed!"
            exit 1
          fi
        fi

artifacts:
  files:
    - integration-test-report.json
    - response.json
    - error-response.json
    - perf-response.json
    - load-response-*.json
  
  name: integration-test-results

reports:
  integration-test-reports:
    files:
      - integration-test-report.json
    file-format: JUNITXML